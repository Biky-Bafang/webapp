import{s as M,z as P,w as Q,a as U,g as X,i as j,A as Y,f as B,B as G,C as Z,D as w,q as O,E as x,F as $,G as ee,H as oe,t as le,d as te,j as re}from"./scheduler.C25rSTt5.js";import{S as se,i as ae,f as ne,c as D,a as L,m as E,t as m,b as g,d as W,g as ie,e as fe}from"./index.CiCksDGq.js";import{c as be,B as ue,g as v,a as J}from"./stores.Dsg8gpKN.js";import{E as me,T as ce}from"./Text.1a_6ePl2.js";const z={xs:1,sm:2,md:3,lg:4,xl:5},_e=be((l,{color:o,size:e,variant:t})=>{const{size:s,themeColor:a}=l.fn;return{root:{},horizontal:{border:0,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderTopColor:a(o,4),borderTopStyle:t,margin:"12px 0px 12px 0px"},vertical:{border:0,alignSelf:"stretch",height:"100%",borderLeftWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderLeftColor:a(o,4),borderLeftStyle:t},showsLabel:{borderTop:"0 !important"},label:{display:"flex",alignItems:"center",color:o==="dark"?a("dark",1):a(o,6),[`${l.dark} &`]:{color:o==="dark"?a("dark",1):a(o,5)},"&.left":{"&::before":{display:"none"}},"&.right":{"&::after":{display:"none"}},"&::before":{content:'""',flex:1,height:1,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderTopStyle:`${t}`,borderTopColor:a(o,4),marginRight:"10px",[`${l.dark} &`]:{borderTopColor:a(o,3)}},"&::after":{content:'""',flex:1,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderTopStyle:`${t}`,borderTopColor:a(o,3),marginLeft:"10px"}}}}),ge=Object.freeze([{error:!0,message:"If using label or label slot, it cannot use orientation 'vertical'",solution:`
                If your component looks like this:
                
                &lt;Divider orientation='vertical' label='text...'&lt;/Divider&gt;
                                        ^^^^^^^^^ - Try changing orientation to 'horizontal'
                `}]),de=l=>({}),R=l=>({});function V(l){var a;let o,e;const t=[{class:l[12](l[11].label,l[6])},l[7],{size:((a=l[7])==null?void 0:a.size)||l[4]}];let s={$$slots:{default:[he]},$$scope:{ctx:l}};for(let n=0;n<t.length;n+=1)s=P(s,t[n]);return o=new ce({props:s}),{c(){D(o.$$.fragment)},l(n){L(o.$$.fragment,n)},m(n,b){E(o,n,b),e=!0},p(n,b){var r;const u=b&6352?v(t,[b&6208&&{class:n[12](n[11].label,n[6])},b&128&&J(n[7]),b&144&&{size:((r=n[7])==null?void 0:r.size)||n[4]}]):{};b&4194336&&(u.$$scope={dirty:b,ctx:n}),o.$set(u)},i(n){e||(m(o.$$.fragment,n),e=!0)},o(n){g(o.$$.fragment,n),e=!1},d(n){W(o,n)}}}function pe(l){let o;return{c(){o=le(l[5])},l(e){o=te(e,l[5])},m(e,t){j(e,o,t)},p(e,t){t&32&&re(o,e[5])},d(e){e&&B(o)}}}function he(l){let o;const e=l[20].label,t=x(e,l,l[22],R),s=t||pe(l);return{c(){s&&s.c()},l(a){s&&s.l(a)},m(a,n){s&&s.m(a,n),o=!0},p(a,n){t?t.p&&(!o||n&4194304)&&$(t,e,a,a[22],o?oe(e,a[22],n,de):ee(a[22]),R):s&&s.p&&(!o||n&32)&&s.p(a,o?n:-1)},i(a){o||(m(s,a),o=!0)},o(a){g(s,a),o=!1},d(a){s&&s.d(a)}}}function ke(l){let o,e,t=l[15]&&V(l);return{c(){t&&t.c(),o=O()},l(s){t&&t.l(s),o=O()},m(s,a){t&&t.m(s,a),j(s,o,a),e=!0},p(s,a){s[15]?t?(t.p(s,a),a&32768&&m(t,1)):(t=V(s),t.c(),m(t,1),t.m(o.parentNode,o)):t&&(ie(),g(t,1,1,()=>{t=null}),fe())},i(s){e||(m(t),e=!0)},o(s){g(t),e=!1},d(s){s&&B(o),t&&t.d(s)}}}function Te(l){let o,e,t,s,a;o=new me({props:{observable:l[8],component:"Divider",code:l[9]}});const n=[{use:l[2]},{class:l[12](l[3],l[11].root,l[14]?l[11].horizontal:{},l[13]?l[11].vertical:{},l[15]?l[11].showsLabel:{},l[10]({css:l[1]}))},l[16]];function b(r){l[21](r)}let u={$$slots:{default:[ke]},$$scope:{ctx:l}};for(let r=0;r<n.length;r+=1)u=P(u,n[r]);return l[0]!==void 0&&(u.element=l[0]),t=new ue({props:u}),Q.push(()=>ne(t,"element",b)),{c(){D(o.$$.fragment),e=U(),D(t.$$.fragment)},l(r){L(o.$$.fragment,r),e=X(r),L(t.$$.fragment,r)},m(r,f){E(o,r,f),j(r,e,f),E(t,r,f),a=!0},p(r,[f]){const c={};f&256&&(c.observable=r[8]),f&512&&(c.code=r[9]),o.$set(c);const _=f&130062?v(n,[f&4&&{use:r[2]},f&64522&&{class:r[12](r[3],r[11].root,r[14]?r[11].horizontal:{},r[13]?r[11].vertical:{},r[15]?r[11].showsLabel:{},r[10]({css:r[1]}))},f&65536&&J(r[16])]):{};f&4233456&&(_.$$scope={dirty:f,ctx:r}),!s&&f&1&&(s=!0,_.element=r[0],Y(()=>s=!1)),t.$set(_)},i(r){a||(m(o.$$.fragment,r),m(t.$$.fragment,r),a=!0)},o(r){g(o.$$.fragment,r),g(t.$$.fragment,r),a=!1},d(r){r&&B(e),W(o,r),W(t,r)}}}function ye(l,o,e){let t,s,a,n,b,u;const r=["use","element","class","override","color","orientation","size","label","labelPosition","labelProps","variant"];let f=G(o,r),{$$slots:c={},$$scope:_}=o;const I=Z(c);let{use:q=[],element:T=void 0,class:F="",override:S={},color:d="gray",orientation:p="horizontal",size:h="xs",label:y=null,labelPosition:H="left",labelProps:N=null,variant:k="solid"}=o,C=!1,A;s&&(y||I.label)&&(C=!0,A=ge[0]);function K(i){T=i,e(0,T)}return l.$$set=i=>{o=P(P({},o),w(i)),e(16,f=G(o,r)),"use"in i&&e(2,q=i.use),"element"in i&&e(0,T=i.element),"class"in i&&e(3,F=i.class),"override"in i&&e(1,S=i.override),"color"in i&&e(17,d=i.color),"orientation"in i&&e(18,p=i.orientation),"size"in i&&e(4,h=i.size),"label"in i&&e(5,y=i.label),"labelPosition"in i&&e(6,H=i.labelPosition),"labelProps"in i&&e(7,N=i.labelProps),"variant"in i&&e(19,k=i.variant),"$$scope"in i&&e(22,_=i.$$scope)},l.$$.update=()=>{l.$$.dirty&262176&&e(15,t=(y||I.label)&&p==="horizontal"),l.$$.dirty&262144&&e(13,s=p==="vertical"),l.$$.dirty&262144&&e(14,a=p==="horizontal"),l.$$.dirty&256&&C&&e(1,S={display:"none"}),l.$$.dirty&655376&&e(12,{cx:n,classes:b,getStyles:u}=_e({color:d,size:h,variant:k},{name:"Divider"}),n,(e(11,b),e(17,d),e(4,h),e(19,k)),(e(10,u),e(17,d),e(4,h),e(19,k)))},[T,S,q,F,h,y,H,N,C,A,u,b,n,s,a,t,f,d,p,k,c,K,_]}class De extends se{constructor(o){super(),ae(this,o,ye,Te,M,{use:2,element:0,class:3,override:1,color:17,orientation:18,size:4,label:5,labelPosition:6,labelProps:7,variant:19})}}export{De as D};
