import{s as M,r as z,l as Q,a as U,g as X,i as E,m as Y,f as I,o as O,p as Z,u as w,D as R,v as x,w as $,x as ee,y as oe,t as le,d as te,j as re}from"./scheduler.Cabs2qPT.js";import{S as se,i as ae,b as ne,c as L,a as C,m as j,t as m,d as g,e as W,g as ie,f as fe}from"./index.CisEW8ZJ.js";import{i as be,j as ue,g as G,a as J}from"./stores.DfX1f76V.js";import{E as me,T as ce}from"./Text.CdW7TBh3.js";const P={xs:1,sm:2,md:3,lg:4,xl:5},_e=be((l,{color:o,size:e,variant:t})=>{const{size:s,themeColor:a}=l.fn;return{root:{},horizontal:{border:0,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:P}),borderTopColor:a(o,4),borderTopStyle:t,margin:"12px 0px 12px 0px"},vertical:{border:0,alignSelf:"stretch",height:"100%",borderLeftWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:P}),borderLeftColor:a(o,4),borderLeftStyle:t},showsLabel:{borderTop:"0 !important"},label:{display:"flex",alignItems:"center",color:o==="dark"?a("dark",1):a(o,6),[`${l.dark} &`]:{color:o==="dark"?a("dark",1):a(o,5)},"&.left":{"&::before":{display:"none"}},"&.right":{"&::after":{display:"none"}},"&::before":{content:'""',flex:1,height:1,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:P}),borderTopStyle:`${t}`,borderTopColor:a(o,4),marginRight:"10px",[`${l.dark} &`]:{borderTopColor:a(o,3)}},"&::after":{content:'""',flex:1,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:P}),borderTopStyle:`${t}`,borderTopColor:a(o,3),marginLeft:"10px"}}}}),ge=Object.freeze([{error:!0,message:"If using label or label slot, it cannot use orientation 'vertical'",solution:`
                If your component looks like this:
                
                &lt;Divider orientation='vertical' label='text...'&lt;/Divider&gt;
                                        ^^^^^^^^^ - Try changing orientation to 'horizontal'
                `}]),pe=l=>({}),V=l=>({});function A(l){var a;let o,e;const t=[{class:l[12](l[11].label,l[6])},l[7],{size:((a=l[7])==null?void 0:a.size)||l[4]}];let s={$$slots:{default:[he]},$$scope:{ctx:l}};for(let n=0;n<t.length;n+=1)s=z(s,t[n]);return o=new ce({props:s}),{c(){L(o.$$.fragment)},l(n){C(o.$$.fragment,n)},m(n,b){j(o,n,b),e=!0},p(n,b){var r;const u=b&6352?G(t,[b&6208&&{class:n[12](n[11].label,n[6])},b&128&&J(n[7]),b&144&&{size:((r=n[7])==null?void 0:r.size)||n[4]}]):{};b&4194336&&(u.$$scope={dirty:b,ctx:n}),o.$set(u)},i(n){e||(m(o.$$.fragment,n),e=!0)},o(n){g(o.$$.fragment,n),e=!1},d(n){W(o,n)}}}function de(l){let o;return{c(){o=le(l[5])},l(e){o=te(e,l[5])},m(e,t){E(e,o,t)},p(e,t){t&32&&re(o,e[5])},d(e){e&&I(o)}}}function he(l){let o;const e=l[20].label,t=x(e,l,l[22],V),s=t||de(l);return{c(){s&&s.c()},l(a){s&&s.l(a)},m(a,n){s&&s.m(a,n),o=!0},p(a,n){t?t.p&&(!o||n&4194304)&&$(t,e,a,a[22],o?oe(e,a[22],n,pe):ee(a[22]),V):s&&s.p&&(!o||n&32)&&s.p(a,o?n:-1)},i(a){o||(m(s,a),o=!0)},o(a){g(s,a),o=!1},d(a){s&&s.d(a)}}}function ke(l){let o,e,t=l[15]&&A(l);return{c(){t&&t.c(),o=R()},l(s){t&&t.l(s),o=R()},m(s,a){t&&t.m(s,a),E(s,o,a),e=!0},p(s,a){s[15]?t?(t.p(s,a),a&32768&&m(t,1)):(t=A(s),t.c(),m(t,1),t.m(o.parentNode,o)):t&&(ie(),g(t,1,1,()=>{t=null}),fe())},i(s){e||(m(t),e=!0)},o(s){g(t),e=!1},d(s){s&&I(o),t&&t.d(s)}}}function Te(l){let o,e,t,s,a;o=new me({props:{observable:l[8],component:"Divider",code:l[9]}});const n=[{use:l[2]},{class:l[12](l[3],l[11].root,l[14]?l[11].horizontal:{},l[13]?l[11].vertical:{},l[15]?l[11].showsLabel:{},l[10]({css:l[1]}))},l[16]];function b(r){l[21](r)}let u={$$slots:{default:[ke]},$$scope:{ctx:l}};for(let r=0;r<n.length;r+=1)u=z(u,n[r]);return l[0]!==void 0&&(u.element=l[0]),t=new ue({props:u}),Q.push(()=>ne(t,"element",b)),{c(){L(o.$$.fragment),e=U(),L(t.$$.fragment)},l(r){C(o.$$.fragment,r),e=X(r),C(t.$$.fragment,r)},m(r,f){j(o,r,f),E(r,e,f),j(t,r,f),a=!0},p(r,[f]){const c={};f&256&&(c.observable=r[8]),f&512&&(c.code=r[9]),o.$set(c);const _=f&130062?G(n,[f&4&&{use:r[2]},f&64522&&{class:r[12](r[3],r[11].root,r[14]?r[11].horizontal:{},r[13]?r[11].vertical:{},r[15]?r[11].showsLabel:{},r[10]({css:r[1]}))},f&65536&&J(r[16])]):{};f&4233456&&(_.$$scope={dirty:f,ctx:r}),!s&&f&1&&(s=!0,_.element=r[0],Y(()=>s=!1)),t.$set(_)},i(r){a||(m(o.$$.fragment,r),m(t.$$.fragment,r),a=!0)},o(r){g(o.$$.fragment,r),g(t.$$.fragment,r),a=!1},d(r){r&&I(e),W(o,r),W(t,r)}}}function ye(l,o,e){let t,s,a,n,b,u;const r=["use","element","class","override","color","orientation","size","label","labelPosition","labelProps","variant"];let f=O(o,r),{$$slots:c={},$$scope:_}=o;const N=Z(c);let{use:q=[],element:T=void 0,class:v="",override:S={},color:p="gray",orientation:d="horizontal",size:h="xs",label:y=null,labelPosition:B="left",labelProps:F=null,variant:k="solid"}=o,D=!1,H;s&&(y||N.label)&&(D=!0,H=ge[0]);function K(i){T=i,e(0,T)}return l.$$set=i=>{o=z(z({},o),w(i)),e(16,f=O(o,r)),"use"in i&&e(2,q=i.use),"element"in i&&e(0,T=i.element),"class"in i&&e(3,v=i.class),"override"in i&&e(1,S=i.override),"color"in i&&e(17,p=i.color),"orientation"in i&&e(18,d=i.orientation),"size"in i&&e(4,h=i.size),"label"in i&&e(5,y=i.label),"labelPosition"in i&&e(6,B=i.labelPosition),"labelProps"in i&&e(7,F=i.labelProps),"variant"in i&&e(19,k=i.variant),"$$scope"in i&&e(22,_=i.$$scope)},l.$$.update=()=>{l.$$.dirty&262176&&e(15,t=(y||N.label)&&d==="horizontal"),l.$$.dirty&262144&&e(13,s=d==="vertical"),l.$$.dirty&262144&&e(14,a=d==="horizontal"),l.$$.dirty&256&&D&&e(1,S={display:"none"}),l.$$.dirty&655376&&e(12,{cx:n,classes:b,getStyles:u}=_e({color:p,size:h,variant:k},{name:"Divider"}),n,(e(11,b),e(17,p),e(4,h),e(19,k)),(e(10,u),e(17,p),e(4,h),e(19,k)))},[T,S,q,v,h,y,B,F,D,H,u,b,n,s,a,t,f,p,d,k,c,K,_]}class Le extends se{constructor(o){super(),ae(this,o,ye,Te,M,{use:2,element:0,class:3,override:1,color:17,orientation:18,size:4,label:5,labelPosition:6,labelProps:7,variant:19})}}export{Le as D};
